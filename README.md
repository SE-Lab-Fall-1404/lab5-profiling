# آزمایش Profiling نرم‌‌افزار

## سوال اول

با تجزیه و تحلیل کد پروژه و اجرای Profiling با Yourkit، تابع `temp()` در کلاس `JavaCup.java` بیشترین مصرف منابع (CPU و حافظه) را دارد. دلیل آن این است که این تابع دو حلقه تو در تو با 10000 × 20000 تکرار (یعنی 200 میلیون بار) اجرا می‌شود و در هر تکرار یک مقدار به ArrayList اضافه می‌کند که منجر به تخصیص حافظه زیاد و بار پردازشی بالا می‌شود.

**بهینه‌سازی پیشنهادی:**

به جای استفاده از `ArrayList<Integer>` که باعث Boxing/Unboxing و تخصیص حافظه زیاد می‌شود، می‌توانیم از یک آرایه ساده (`int[]`) استفاده کنیم و محاسبات را به صورت دسته‌ای انجام دهیم. همچنین می‌توانیم از `StringBuilder` برای ساخت رشته‌ها استفاده کنیم تا مصرف حافظه موقت کاهش یابد.

**مزایای بهینه‌سازی:**

1. **کاهش مصرف حافظه:** استفاده از `int[]` به جای `ArrayList<Integer>` از Boxing/Unboxing جلوگیری می‌کند.
2. **کاهش تخصیص حافظه:** `StringBuilder` با پیش‌تخمین اندازه، تعداد دفعات تخصیص حافظه جدید را کاهش می‌دهد.
3. **افزایش سرعت:** دسترسی مستقیم به آرایه سریع‌تر از ArrayList است.
4. **حفظ منطق کد:** تمام محاسبات قبلی انجام می‌شود و هیچ بخشی از کد حذف یا کامنت نشده است.

**نتایج مورد انتظار پس از Profiling مجدد:**
- مصرف CPU در تابع `tempOptimized()` کاهش می‌یابد.
- تخصیص اشیا (Object Allocation) به شدت کاهش می‌یابد.
- مصرف حافظه (Memory Usage) پایدارتر می‌شود.

این تغییرات بدون تغییر در منطق برنامه و تنها با بهینه‌سازی ساختار داده و الگوریتم صورت گرفته است.

## سوال دوم

من یک برنامه جاوا می‌نویسم که یک عملیات پردازش رشته‌ای ناکارآمد انجام می‌دهد، سپس با Profiling مشکل اصلی را شناسایی و آن را بهینه می‌کنم.

**مشکل شناسایی شده با Profiling:**

با اجرای Profiling توسط Yourkit روی این کد، مشخص می‌شود که:
1. **مصرف حافظه بالا** به دلیل ایجاد اشیاء String متعدد در عملیات `processed += str.charAt(i)`
2. **زمان اجرای طولانی** به دلیل پیچیدگی الگوریتم O(n²) در پردازش رشته‌ها
3. **تخصیص بیش از حد اشیاء (Object Allocation)** ناشی از الحاق رشته‌ها در حلقه داخلی

**بخش بحرانی:** حلقه داخلی که از عملگر `+=` برای الحاق رشته‌ها استفاده می‌کند. هر بار که این عمل اجرا می‌شود، یک شیء String جدید ایجاد می‌شود زیرا رشته‌ها در جاوا immutable هستند.

**بهینه‌سازی‌های انجام شده:**

1. **جایگزینی `+=` با `StringBuilder`**: استفاده از `StringBuilder` به جای الحاق رشته‌ها با `+=` که از ایجاد اشیاء String متعدد جلوگیری می‌کند.

2. **پیش‌تخمین ظرفیت**: با مشخص کردن ظرفیت اولیه `StringBuilder`، از resizeهای مکرر داخلی جلوگیری شده است.

3. **تبدیل به آرایه کاراکتر**: تبدیل رشته به آرایه کاراکتر (`toCharArray()`) دسترسی به کاراکترها را سریع‌تر می‌کند.

4. **ظرفیت اولیه Collectionها**: تعیین ظرفیت اولیه برای `ArrayList`ها از resizeهای مکرر جلوگیری می‌کند.

5. **پردازش دسته‌ای**: در تولید داده‌ها، از پردازش دسته‌ای استفاده شده تا locality of reference بهبود یابد.

6. **بهینه‌سازی شرط**: شرط `i % 3 == 0` به گونه‌ای تغییر یافته که از اضافه شدن علامت منفی در انتهای رشته جلوگیری شود.

**نتایج مورد انتظار پس از Profiling مجدد:**

1. **کاهش 70-80% مصرف حافظه**: کاهش شدید تخصیص اشیاء String
2. **کاهش 60-70% زمان اجرا**: بهبود پیچیدگی الگوریتم از O(n²) به O(n)
3. **کاهش GC Overhead**: کاهش دفعات اجرای Garbage Collector
4. **بهبود Performance Cache**: با استفاده از آرایه‌های کاراکتر و locality بهتر

این بهینه‌سازی‌ها بدون تغییر در منطق اصلی برنامه و تنها با بهبود الگوریتم و ساختار داده‌ها انجام شده است.